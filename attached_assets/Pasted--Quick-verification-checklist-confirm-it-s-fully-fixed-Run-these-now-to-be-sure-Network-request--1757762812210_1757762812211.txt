âœ… Quick verification checklist (confirm itâ€™s fully fixed)
Run these now to be sure:
Network request
DevTools â†’ Network â†’ reload Local Listings tab â†’ locate /api/local-listings. Confirm 200 and response body is an array of CachedPortalListing with 5 items.
Console fetch test
Run in browser console:
fetch('/api/local-listings').then(r=>r.json()).then(d=>console.log('api',d, 'len', (d.listings||d).length)).catch(console.error);
You should see 5 items.
Component-level log (temporary)
In home.tsx add:
useEffect(() => {
  console.log("LocalListings data:", data, "isLoading:", isLoading, "error:", error);
}, [data, isLoading, error]);
Confirm console shows data with 5 items when the page loads.
DOM inspection
Inspect the element where listings render. Are <ListingCard> elements present? If yes, CSS/display is fine.
Map fields
Verify the render uses keys that exist:
// e.g. if listing uses title
<div>{listing.title ?? listing.heading ?? listing.name}</div>
If all pass, close the ticket.
âœ³ï¸ Additional checks if something still fails
Confirm the fetch returns the array directly or a wrapper ({ listings: [...] }). Adjust the fetch helper accordingly:
const json = await res.json();
return json.listings ?? json; // return an array
Check for stale query keys or stale cache: call queryClient.invalidateQueries('localListings') after fix or clear the cache.
Ensure any auth/CORS headers are present â€” but you already saw 200 responses so this is unlikely.
ðŸ›¡ Prevent this from recurring â€” recommended hardening
Add runtime validation (contract enforcement)
Use a lightweight runtime schema check (zod or io-ts) in the frontend fetcher:
import { z } from "zod";
const CachedPortalListing = z.object({
  id: z.string(),
  title: z.string().optional(),
  price: z.union([z.number(), z.string()]).optional(),
  // ...other fields
});
const ListingsResponse = z.array(CachedPortalListing);

async function fetchLocalListings() {
  const res = await fetch('/api/local-listings');
  const json = await res.json();
  return ListingsResponse.parse(json.listings ?? json); // throws if mismatch
}
This surfaces differences at runtime immediately (and fails fast during dev).
Schema/contract tests (CI)
Add a lightweight contract test: CI fetches the real API (or a stub) and asserts shape with zod. Fails the build when mismatch occurs.
Centralize the types
Export a shared types package (or shared/ module) that both backend and frontend import, so they share a single true canonical type. If the backend canâ€™t import TS types, keep a single .d.ts file source-of-truth.
API wrapper normalization
Have a single fetch wrapper that normalizes the backend payload into the frontendâ€™s expected minimal Car shape:
function toCar(listing: CachedPortalListing): Car {
  return {
    id: listing.id,
    title: listing.title ?? listing.heading ?? 'Unknown',
    price: Number(listing.price) || null,
    ...
  }
}
Logging & Alerts
Add client-side logging when data is empty but API returned items (send to Sentry/Loggly).
Add backend telemetry for response shapes (count fields present) so you see schema drift early.
Automated smoke test for HMR
After a type-related change, run a headless smoke test that fetches /local-listings and validates DOM insertion. This catches regressions before QA.
ðŸ§¾ Quick PR checklist you can use
 Backend returns documented swagger/openapi for /api/local-listings.
 Frontend uses type definitions from shared source.
 Fetch wrapper normalizes payload to expected Car type.
 Add zod validation in fetcher and tests in CI.
 Add a small E2E smoke test that hits the running dev server and asserts #local-listings .listing-card length > 0.